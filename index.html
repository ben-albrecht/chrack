
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Dimensional Charting</title>
    <link rel="stylesheet" type="text/css" href="http://dc-js.github.io/dc.js/css/dc.css"/>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/d3.js"></script>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/crossfilter.js"></script>
    <script type="text/javascript" src="http://dc-js.github.io/dc.js/js/dc.js"></script>
    <style>
         .heat-box {
           stroke: #E6E6E6;
           stroke-width: 2px;
         }
    </style>
</head>
<body>
  <div id="test"></div>
  <div class=".dc-data-table" id="event-table"></div>

<script>
var maxCount = 0;
var data = {
  0: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  1: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  2: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  },
  3: {
    0: { count: 0, events: [] },
    1: { count: 0, events: [] },
    2: { count: 0, events: [] },
    3: { count: 0, events: [] }
  }
}
var transformCountsToChartData = function() {
  var chartData = [];
  for (var src_node_id in data) {
    for (var dest_node_id in data[src_node_id]) {
      if (!isNaN(src_node_id) && !isNaN(dest_node_id)) {
        var ndxData = {
          key: [src_node_id, dest_node_id],
          count: data[src_node_id][dest_node_id].count
        }
        chartData.push(ndxData);
      }
    }
  }
  return chartData;
}

var ndx       = crossfilter(transformCountsToChartData()),
    runDim    = ndx.dimension(function(d) { return [+d.key[0], +d.key[1]]; }),
    runGroup  = runDim.group().reduceSum(function(d) { return +d.count; });

var heatColorMapping = function(d) {
  return d3.scale.linear().domain([0,maxCount]).range(["lightgray", "red"])(d);
};
heatColorMapping.domain = function() {
  return [0,maxCount];
};

var chart = dc.heatMap("#test");
chart
  .width(45 * 20 + 80)
  .height(45 * 5 + 40)
  .dimension(runDim)
  .group(runGroup)
  .keyAccessor(function(d) { return +d.key[0]; })
  .valueAccessor(function(d) { return +d.key[1]; })
  .colorAccessor(function(d) { return +d.value; })
  .colors(heatColorMapping)
  .calculateColorDomain();
chart.render();

var countDimension = ndx.dimension(function (d) {
    return d.count;
});

var nasdaqTable = dc.dataTable('.dc-data-table');
nasdaqTable /* dc.dataTable('.dc-data-table', 'chartGroup') */
  .dimension(countDimension)
  // Data table does not use crossfilter group but rather a closure
  // as a grouping function
  .group(function (d) {
     var format = d3.format('02d');
     return format((d.count);
  })
  // (_optional_) max number of records to be shown, `default = 25`
  // .size(10)
  // There are several ways to specify the columns; see the data-table documentation.
  // This code demonstrates generating the column header automatically based on the columns.
  .columns([
     'count',
     'line_no',
     'filename'
  ])
  // (_optional_) sort using the given field, `default = function(d){return d;}`
  .sortBy(function (d) {
     return d.count;
  })
  // (_optional_) sort order, `default = d3.ascending`
  .order(d3.descending)
  // (_optional_) custom renderlet to post-process chart using [D3](http://d3js.org)
  );


var periodicUpdater = function() {
  ndx.add(transformCountsToChartData());
  dc.redrawAll();
}

var connection
window.addEventListener("load", function () {
	connection = new WebSocket("ws://"+window.location.hostname+":8081")
	connection.onopen = function () {
		console.log("Connection opened")
	}
	connection.onclose = function () {
		console.log("Connection closed")
	}
	connection.onerror = function () {
		console.error("Connection error")
	}
	connection.onmessage = function (event) {
    var clientData = JSON.parse(event.data);
    clientData.forEach(function(row) {
      var intersection = data[row.src_node_id][row.dest_node_id];
      intersection.count += 1;
      intersection.events.push(row);
      if (maxCount < intersection.count) {
        maxCount = intersection.count;
      }
    })
	}

  window.setInterval(periodicUpdater, 2000);
})
</script>
</body>
</html>
